# ══════════════════════════════════════════════════════════════════════════════
#
#  .env.example — Polymarket Multi-Strategy Bot
#
#  Copy this file to .env and fill in your values.
#  Run `python setup.py` to auto-fill credentials and validate everything.
#
#  NEVER commit .env — it contains your private key.
#
# ══════════════════════════════════════════════════════════════════════════════


# ══════════════════════════════════════════════════════════════════════════════
#  WALLET & AUTH
#  Used by: all bots
#
#  POLY_PRIVATE_KEY   Your EOA signer private key (0x...)
#  FUNDER_ADDRESS     Your proxy wallet address — this is where USDC is held
#  POLY_RPC           Polygon RPC endpoint (Alchemy, Infura, or public)
#  SIGNATURE_TYPE     2 = proxy wallet (recommended)
#                     0 = EOA direct
#                     1 = Magic.Link
# ══════════════════════════════════════════════════════════════════════════════
POLY_PRIVATE_KEY=0x_YOUR_PRIVATE_KEY_HERE
FUNDER_ADDRESS=0x_YOUR_PROXY_WALLET_HERE
POLY_RPC=https://polygon-mainnet.g.alchemy.com/v2/YOUR_KEY
SIGNATURE_TYPE=2


# ══════════════════════════════════════════════════════════════════════════════
#  API CREDENTIALS
#  Used by: all bots
#
#  Auto-generated from your private key by running: python setup.py
#  To regenerate: python setup.py --regen-keys
# ══════════════════════════════════════════════════════════════════════════════
POLY_API_KEY=
POLY_API_SECRET=
POLY_API_PASSPHRASE=


# ══════════════════════════════════════════════════════════════════════════════
#  ORDER EXECUTION
#  Used by: all bots
#
#  BUY_ORDER_TYPE
#    FAK  — Fill And Kill. Immediate market fill at best available price.
#           Most reliable for liquid markets. Uses MarketOrderArgs.
#    FOK  — Fill Or Kill. Limit order — fill fully at exact price or cancel.
#           Set FOK_GTC_FALLBACK=true to retry as GTC on liquidity failure.
#    GTC  — Good Till Cancelled. Rests in the order book until filled.
#           Auto-cancelled after GTC_TIMEOUT_SECONDS if set.
#
#  SELL_ORDER_TYPE
#    Order type for bracket SELL orders (take profit + stop loss).
#    Used by Strategy 1 (DCA Snipe) only. GTC recommended.
#
#  GTC_TIMEOUT_SECONDS
#    Auto-cancel GTC orders after this many seconds.
#    null = never auto-cancel.
#
#  FOK_GTC_FALLBACK
#    true  = if FOK fails due to insufficient liquidity, retry as GTC
#    false = cancel on FOK liquidity failure
#
#  WSS_READY_TIMEOUT
#    Seconds to wait for WebSocket before falling back to REST.
# ══════════════════════════════════════════════════════════════════════════════
BUY_ORDER_TYPE=FOK
SELL_ORDER_TYPE=FAK
GTC_TIMEOUT_SECONDS=30
FOK_GTC_FALLBACK=false
WSS_READY_TIMEOUT=10.0


# ══════════════════════════════════════════════════════════════════════════════
#  AUTO CLAIM  (auto_claim.py)
#
#  CLAIM_CHECK_INTERVAL
#    Seconds between each check in polling mode (CHECK_REAL_TIME=false).
#    Default: 60 (1 minute).
#
#  CHECK_REAL_TIME
#    true  → WebSocket real-time mode.
#             Subscribes to the market price feed for all held positions.
#             Triggers redemption immediately when a price hits 0.99 or 0.01.
#             Refreshes subscription list every 2 minutes for new positions.
#    false → Polling mode. Checks every CLAIM_CHECK_INTERVAL seconds.
# ══════════════════════════════════════════════════════════════════════════════
CLAIM_CHECK_INTERVAL=60
CHECK_REAL_TIME=false


# ══════════════════════════════════════════════════════════════════════════════
#
#  STRATEGY 1 — DCA SNIPE
#  File: strategies/DCA_Snipe/markets/{btc,eth,sol,xrp}/bot.py
#  Run:  python main.py --strategy dca --operate btc eth sol xrp --interval 15m
#
#  Monitors UP and DOWN prices via WebSocket (market_stream.py).
#  Waits for either side to cross ENTRY_PRICE from below (entry arming).
#  On trigger: places a buy, optionally places GTC bracket TP+SL orders,
#  and optionally DCA on each BET_STEP increment.
#
#  Intervals: 5m | 15m | 1h
#    5m/15m  → market slug: sol-updown-{interval}-{unix_timestamp}
#    1h      → event slug:  solana-up-or-down-{month}-{day}-{hour}{am/pm}-et
#              e.g. solana-up-or-down-february-25-12pm-et
#
#  AUTOSET_UP_TP_SL_ORDERS
#    true  (default) → immediately after each BUY, place GTC TP+SL bracket
#                      orders in the book. Requires approve_ctf.py to have
#                      been run once — otherwise SELL will fail with
#                      "not enough balance / allowance".
#    false           → NO bracket orders placed after BUY. TP and SL are
#                      monitored manually by watching the price feed.
#                      Use this mode if approve_ctf.py hasn't been run yet,
#                      or when you want full manual control over exits.
#
#  Stop loss modes (priority: OFFSET > STOP_LOSS > break-even):
#    Fixed:      STOP_LOSS=0.55   STOP_LOSS_OFFSET=null
#    Dynamic:    STOP_LOSS=null   STOP_LOSS_OFFSET=0.02  (SL = avg_entry - offset)
#    Break-even: STOP_LOSS=null   STOP_LOSS_OFFSET=null  (SL = avg_entry - 1 tick)
#    Disabled:   {ASSET}_USE_STOP_LOSS=false              (TP only, no SL at all)
#
# ══════════════════════════════════════════════════════════════════════════════
AUTOSET_UP_TP_SL_ORDERS=true

# ── Bitcoin ───────────────────────────────────────────────────────────────────
BTC_USE_STOP_LOSS=true
BTC_ENTRY_PRICE=0.60
BTC_AMOUNT_PER_BET=1.5
BTC_TAKE_PROFIT=0.80
BTC_STOP_LOSS=0.58
BTC_STOP_LOSS_OFFSET=0.02
BTC_BET_STEP=null
BTC_POLL_INTERVAL=0.1

# ── Ethereum ──────────────────────────────────────────────────────────────────
ETH_USE_STOP_LOSS=true
ETH_ENTRY_PRICE=0.70
ETH_AMOUNT_PER_BET=1.5
ETH_TAKE_PROFIT=0.82
ETH_STOP_LOSS=0.68
ETH_STOP_LOSS_OFFSET=null
ETH_BET_STEP=null
ETH_POLL_INTERVAL=0.1

# ── Solana ────────────────────────────────────────────────────────────────────
SOL_USE_STOP_LOSS=true
SOL_ENTRY_PRICE=0.60
SOL_AMOUNT_PER_BET=5.0
SOL_TAKE_PROFIT=0.85
SOL_STOP_LOSS=null
SOL_STOP_LOSS_OFFSET=0.02
SOL_BET_STEP=0.05
SOL_POLL_INTERVAL=0.1

# ── Ripple ────────────────────────────────────────────────────────────────────
XRP_USE_STOP_LOSS=true
XRP_ENTRY_PRICE=0.70
XRP_AMOUNT_PER_BET=1.5
XRP_TAKE_PROFIT=0.95
XRP_STOP_LOSS=0.60
XRP_STOP_LOSS_OFFSET=0.02
XRP_BET_STEP=null
XRP_POLL_INTERVAL=0.1


# ══════════════════════════════════════════════════════════════════════════════
#
#  STRATEGY 2 — YES+NO ARBITRAGE
#  File: strategies/YES+NO_1usd/markets/{btc,eth,sol,xrp}/bot.py
#  Run:  python main.py --strategy yesno --operate all --interval 5m
#
#  Buys both UP and DOWN so combined cost < $1.00.
#  One side always resolves to $1.00 → guaranteed profit.
#
#  LOSS_PREVENTION=false  (Standard)
#    Both sides watch PRICE_RANGE. Buy each with AMOUNT_TO_BUY when in range.
#
#  LOSS_PREVENTION=true  (Two-phase)
#    Phase 1: first side to hit TRIGGER_RANGE is bought with auto-calculated
#             amount = AMOUNT_TO_BUY x P/(1-P) x (1+TRIGGER_PROFIT_MARGIN)
#    Phase 2: opposite side bought with AMOUNT_TO_BUY when it hits PRICE_RANGE.
#    This guarantees profit regardless of which side wins.
#
# ══════════════════════════════════════════════════════════════════════════════

# ── Bitcoin ───────────────────────────────────────────────────────────────────
BTC_LOSS_PREVENTION=false
BTC_PRICE_RANGE=0.40-0.45
BTC_TRIGGER_RANGE=0.52-0.54
BTC_AMOUNT_TO_BUY=1.0
BTC_TRIGGER_PROFIT_MARGIN=0.05

# ── Ethereum ──────────────────────────────────────────────────────────────────
ETH_LOSS_PREVENTION=false
ETH_PRICE_RANGE=0.40-0.45
ETH_TRIGGER_RANGE=0.52-0.54
ETH_AMOUNT_TO_BUY=1.0
ETH_TRIGGER_PROFIT_MARGIN=0.05

# ── Solana ────────────────────────────────────────────────────────────────────
SOL_LOSS_PREVENTION=false
SOL_PRICE_RANGE=0.40-0.45
SOL_TRIGGER_RANGE=0.52-0.54
SOL_AMOUNT_TO_BUY=1.0
SOL_TRIGGER_PROFIT_MARGIN=0.05

# ── Ripple ────────────────────────────────────────────────────────────────────
XRP_LOSS_PREVENTION=false
XRP_PRICE_RANGE=0.40-0.45
XRP_TRIGGER_RANGE=0.52-0.54
XRP_AMOUNT_TO_BUY=1.0
XRP_TRIGGER_PROFIT_MARGIN=0.05


# ══════════════════════════════════════════════════════════════════════════════
#
#  STRATEGY 3 — COPY TRADE
#  File: strategies/Copy-Trade/bot.py
#  Run:  python main.py --strategy copytrade
#        python strategies/Copy-Trade/bot.py --dry-run
#        python strategies/Copy-Trade/bot.py --mode fixed --amount 2.5
#
#  Monitors wallets in traders.json. Detects new trades in real time and
#  mirrors them. Per-trader reverse_trading and filters set in traders.json.
#
#  COPY_MODE=fixed       → spend exactly COPY_AMOUNT_USDC per trade
#  COPY_MODE=percentage  → spend COPY_PERCENTAGE% of original trade value
#
#  COPY_ORDER_BUY_TYPE / COPY_ORDER_SELL_TYPE
#    Override BUY_ORDER_TYPE for copy trade specifically.
#    FAK | FOK | GTC
#
#  COPY_POLL_INTERVAL
#    null = WebSocket real-time (~50ms detection)
#    N    = REST poll every N seconds (fallback)
#
# ══════════════════════════════════════════════════════════════════════════════
COPY_MODE=fixed
COPY_AMOUNT_USDC=1.0
COPY_PERCENTAGE=10
COPY_ORDER_BUY_TYPE=FAK
COPY_ORDER_SELL_TYPE=FAK
COPY_MIN_TRADE_USDC=0
COPY_MAX_TRADE_USDC=null
COPY_POLL_INTERVAL=null
COPY_DRY_RUN=false


# ══════════════════════════════════════════════════════════════════════════════
#
#  STRATEGY 4 — RSI + VWAP SIGNAL
#  File: strategies/RSI_VWAP_Signal/markets/{btc,eth,sol,xrp}/bot.py
#  Run:  python main.py --strategy rsivwap --operate btc --interval 5m
#
#  Streams 5m candles from Binance WebSocket (no API key needed).
#  Calculates RSI + VWAP in real time.
#  Emits UP / DOWN / NEUTRAL signals with a confidence score (0.0–1.0).
#  Buys Polymarket token when: signal active + conf >= threshold + price in range.
#
#  RSI thresholds:
#    RSI > RSI_OVERBOUGHT (70)        → NEUTRAL, skip UP entries
#    RSI < RSI_OVERSOLD  (30)         → NEUTRAL, skip DOWN entries
#    RSI > RSI_BULL_THRESHOLD (52)    → UP signal (if price also > VWAP)
#    RSI < RSI_BEAR_THRESHOLD (48)    → DOWN signal (if price also < VWAP)
#
#  Confidence score components:
#    45% RSI distance from 50 toward signal direction
#    40% price distance from VWAP (% deviation, capped at 3%)
#    15% fresh signal bonus if RSI just crossed threshold this tick
#
#  {ASSET}_RSI_VWAP_PRICE_RANGE
#    Token must be inside this range to trigger a buy.
#    Prevents buying tokens already priced too high in one direction.
#    Recommended: 0.30-0.55 (balanced market zone)
#
# ══════════════════════════════════════════════════════════════════════════════

# ── Shared signal parameters ──────────────────────────────────────────────────
RSI_PERIOD=14
RSI_OVERBOUGHT=70
RSI_OVERSOLD=30
RSI_BULL_THRESHOLD=52
RSI_BEAR_THRESHOLD=48
MIN_SIGNAL_CONFIDENCE=0.55
SIGNAL_CANDLE_INTERVAL=5m

# ── Bitcoin ───────────────────────────────────────────────────────────────────
BTC_RSI_VWAP_PRICE_RANGE=0.30-0.55
BTC_RSI_VWAP_AMOUNT=1.0

# ── Ethereum ──────────────────────────────────────────────────────────────────
ETH_RSI_VWAP_PRICE_RANGE=0.30-0.55
ETH_RSI_VWAP_AMOUNT=1.0

# ── Solana ────────────────────────────────────────────────────────────────────
SOL_RSI_VWAP_PRICE_RANGE=0.30-0.55
SOL_RSI_VWAP_AMOUNT=1.0
SOL_RSI_VWAP_TAKE_PROFIT=0.82
SOL_RSI_VWAP_STOP_LOSS=null
SOL_RSI_VWAP_POLL_INTERVAL=0.5
SOL_RSI_VWAP_DRY_RUN=false

# ── Ripple ────────────────────────────────────────────────────────────────────
XRP_RSI_VWAP_PRICE_RANGE=0.30-0.55
XRP_RSI_VWAP_AMOUNT=1.0


# ══════════════════════════════════════════════════════════════════════════════
#
#  STRATEGY 4 v2 — RSI+VWAP MULTI-SOURCE  (SOL)
#  File: strategies/RSI_VWAP_Signal/markets/sol/bot.py
#  Run:  python main.py --strategy rsivwap --operate sol --interval 5m
#        python main.py --strategy rsivwap --operate sol --interval 15m
#        python main.py --strategy rsivwap --operate sol --interval 1h
#
#  Combina tres fuentes de datos en un filtro de consenso:
#    1. Binance WebSocket  → RSI + VWAP (momentum técnico)
#    2. ChainLink oracle   → precio on-chain en Polygon (ground truth)
#    3. Polymarket CLOB    → best ask de cada token (precio óptimo de entrada)
#
#  CHAINLINK
#    Requiere POLY_RPC configurado (mismo RPC de Polygon que el bot principal).
#    Si CHAINLINK_ENABLED=false o POLY_RPC está vacío, se omite ChainLink
#    y el consenso se reduce a 2 fuentes (Binance + Polymarket).
#    Contratos SOL/USD en Polygon: 0x10C8264C0935b3B9870013e057f330Ff3e9C56dC
#
#  EARLY WINDOW BET
#    Al abrirse cada ventana de mercado, el bot entra en ZONA PRIME durante
#    los primeros EARLY_BET_WINDOW_SECS segundos (default 90).
#    En esa zona el token UP/DOWN suele cotizar cerca de 0.50 → mejor precio.
#    EARLY_BET_ONLY=true → SOLO entrar en zona PRIME, ignorar el resto.
#
#  GESTIÓN DE RIESGO POST-ENTRADA
#    RISK_STOP_LOSS_ENABLED=true
#      → Si el precio del token cae RISK_STOP_LOSS_PCT bajo el precio de
#        entrada → venta inmediata FAK (cierre de pérdida controlada).
#    RISK_HEDGE_ENABLED=true
#      → Si la pérdida supera RISK_HEDGE_TRIGGER_PCT → se compra el lado
#        contrario con el mismo amount. Ambos lados cubiertos: uno resolverá a $1.
#        Actúa ANTES que el stop-loss (hedge_trigger_pct > stop_loss_pct).
#    RISK_TIME_DECAY_MAX_PCT
#      → No abrir nuevas posiciones tras este porcentaje de la ventana.
#        Default 0.50 = no entrar después del 50% del tiempo de la ventana.
#
#  PRECIO ÓPTIMO DE ENTRADA (best ask)
#    El bot consulta el order book del CLOB para obtener el mejor ask disponible.
#    Esto asegura la entrada al precio más bajo posible en vez del midpoint.
#
# ══════════════════════════════════════════════════════════════════════════════

# ── ChainLink ─────────────────────────────────────────────────────────────────
CHAINLINK_ENABLED=true
CHAINLINK_POLL_INTERVAL=30
CHAINLINK_LOOKBACK_SECS=300
CHAINLINK_MAX_DIVERGENCE=0.015
CHAINLINK_MIN_CHANGE_PCT=0.001

# ── Polymarket order book ─────────────────────────────────────────────────────
POLY_SIGNAL_THRESHOLD=0.52

# ── Consenso multi-fuente ─────────────────────────────────────────────────────
MIN_CONSENSUS_SOURCES=2

# ── Early window BET ──────────────────────────────────────────────────────────
EARLY_BET_WINDOW_SECS=90
EARLY_BET_ONLY=false

# ── Gestión de riesgo post-entrada ────────────────────────────────────────────
RISK_STOP_LOSS_ENABLED=true
RISK_STOP_LOSS_PCT=0.04
RISK_HEDGE_ENABLED=false
RISK_HEDGE_TRIGGER_PCT=0.06
RISK_TIME_DECAY_MAX_PCT=0.50

# ── Multi-entry DCA ───────────────────────────────────────────────────────────
MAX_BETS_PER_SIDE=5        # máx BETs por dirección por ventana (default 5)
BET_COOLDOWN_SECS=90       # segundos mínimos entre BETs en la misma dirección
